# 1. 피보나치 수 2
## 문제 조건
* 0번째 피보나치 수 = 0, 1번째 피보나치 수 = 1  
* 피보나치 수 Fn = Fn-1 + Fn-2 (n ≥ 2)

## 알고리즘 설계
* dp[i] = i번째 피보나치 수  
* dp[i] = dp[i-1] + dp[i-2]

[문제 링크](https://www.acmicpc.net/problem/2748)  
[노션 링크](https://www.notion.so/2-1a4e378b4c3280e6a622c1d6583df3e6)  

---
# 2. 1로 만들기
## 문제 조건
> 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
> 2. X가 2로 나누어 떨어지면, 2로 나눈다.
> 3. 1을 뺀다.

* 정수 N을 1로 만들기 위한 최소 연산 횟수

## 알고리즘 설계
* N → 1 방향, N으로 i번째 정수를 만들기 위한 연산 횟수를 dp배열에 저장
> dp[N] ← 0  
> dp[i] == N이 i가 되기 위한 최소 연산 횟수  
> dp[i] = min(dp[i], dp[n]+1) (n은 N→1로 1씩 감소하는 정수)  

* dp[1]에 N이 1이 되기 위한 최서 연산 횟수가 저장됨

[문제 링크](https://www.acmicpc.net/problem/1463)  
[노션 링크](https://www.notion.so/1-1a4e378b4c32809da30cc642077badb9)  

---
