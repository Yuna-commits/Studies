# 1. DFS와 BFS
## 문제조건
* 1 ≤ N ≤ 1000개의 정점
* DFS, BFS 탐색, 방문할 수 있는 정점이 여러 개인 경우에는 작은 번호를 먼저 방문

## 알고리즘 설계
* 인접행렬을 이용한 DFS, BFS 알고리즘

[문제 링크](https://www.acmicpc.net/problem/1260)  
[노션 링크](https://www.notion.so/DFS-BFS-19de378b4c3280f5a63bc49a5a5b7086)  

---
# 2. 연결 요소의 개수
## 문제 조건
* 방향 없는 그래프
* 연결 요소 : 서로 연결된 정점들의 집합  

## 알고리즘 설계
* BFS 탐색이 가능할 때 cnt 값 증가

[문제 링크](https://www.acmicpc.net/problem/11724)  
[노션 링크](https://www.notion.so/19ee378b4c3280bfb951e75c0b7f9eff)  

---
# 3. 유기농 배추
## 문제 조건
* 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우 서로 인접한 관계
* 서로 인접해 있는 배추들이 몇 군데에 퍼져 있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있음
* 0 : 배추가 심어져 있지 않은 땅, 1 : 배추가 심어져 있는 땅

## 알고리즘 설계
* MxN 크기의 배추밭의 모든 위치에서 BFS 탐색 → 지렁이는 상하좌우 4방향으로 이동하므로 현재 위치에서 지렁이가 이동할 수 있는 모든 곳을 큐에 push
* 한 번의 BFS가 끝남 → 탐색한 그룹에 한 마리의 지렁이가 필요함을 의미

[문제 링크](https://www.acmicpc.net/problem/1012)  
[노션 링크](https://www.notion.so/19fe378b4c32805099bfc66666329b36)  

---
# 4. 단지번호붙이기
## 문제 조건
* NxN 크기 이차원 배열
* 단지 : 어떤 집의 상하좌우로 다른 집이 있는 경우의 집합, 대각선 제외
* 총 단지 수와 각 단지에 속하는 집의 수 구하기

## 알고리즘 설계
* dx[4], dy[4] → 현재 위치 (x, y)에서 상하좌우 4방향으로 이동했을 때의 위치 계산
* group[num] → num : 각 단지에 속하는 집의 수, 전체 단지의 배열
* 브루트포스 : 방문x이고 apt[i][j]가 0이 아닐 때 BFS 탐색
* BFS : 배열의 범위에서 벗어나지 않고 방문x이며 apt[mx][my]가 1일 때 방문체크, 큐 push
* 현재 위치 (x, y)에서 BFS 탐색 진행 → 연결된 모든 집의 개수를 구하고 group 배열에 반환

[문제 링크](https://www.acmicpc.net/problem/2667)  
[노션 링크](https://www.notion.so/1a0e378b4c3280208b4af7390f0a7261)  

---
# 5. 숨바꼭질
## 문제 조건
* 위치 X에 있을 때, 1초 후의 위치  
> 걷는 경우 → X-1 or X+1로 이동  
> 순간이동 → 2*X로 이동
* 수빈이가 동생을 찾을 수 있는 가장 빠른 시간 구하기

## 알고리즘 설계
1차원 BFS 탐색  
* graph[X] : 이전 위치에서 X까지 오는데 걸린 이동 시간  
> e.g. X에서 X+1로 이동하는 경우, graph[X+1] = graph[X]+1하여 이동 시간 계산  
> → Y에서 X+1로 이동하는 경우, graph[Y]+1한 값이 graph[X+1]보다 작다면 graph[Y]+1이 Y에서 X+1까지 가는데 걸리는 최소 시간이다.

* N에서 출발하여 X+1, X-1, 2*X의 위치로 이동하는 모든 경우를 확인

[문제 링크](https://www.acmicpc.net/problem/1697)  
[노션 링크](https://www.notion.so/1a1e378b4c3280a69fdcfb608c7e56f8)  

---
# 6. 숨바꼭질 2
## 문제 조건
* 위치 N에서 K로 가는 최단 시간과 최단 시간으로 가는 방법의 개수 구하기  
* X+1, X-1, 2*X로 이동 가능  
* 방법의 개수를 셀 때, X+1 == 2*X인 경우는 각각 따로 세어야 함(e.g. 1+1=2, 1*2=2)

## 알고리즘 설계
“숨바꼭질” 문제와 마찬가지로 1차원 BFS 사용  

* 처음에는 최단 시간(route[end])을 먼저 구한 후, 목적지로 가는데 걸리는 시간이 최단 시간과 같은 경우를 세는 방식으로 접근하려 했음
  + (if(end==next&&route[end]==route[next]) cnt++) → 예제 출력은 잘 나오지만, 최단 시간 결정 이후 next의 범위를 잡기 위해 넣어야 하는 조건이 쓸데없이 많았음

* 다른 풀이를 찾아보니 route[next]=route[now]+1하여 start에서 next로 가는 최단 시간을 구한 것처럼 방법의 개수도 cnt배열을 사용하여 구하는 방법을 알게 됨

* cnt[next] : start에서 next로 갈 수 있는 방법의 개수, cnt[start]==1  
> case 1: next 위치에 처음 방문하는 경우 → cnt[next]=cnt[now]로 초기화, 최단 시간 갱신  
> case 2: next 위치에 이미 방문했던 경우 → 최단시간이 같으면 cnt[next]+=cnt[now]하여 방법의 개수를 갱신  

[문제 링크](https://www.acmicpc.net/problem/12851)
[노션 링크](https://www.notion.so/2-1a2e378b4c3280ffb578c797fbe5d4c4)  
