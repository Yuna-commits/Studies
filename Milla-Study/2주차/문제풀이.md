# 1. 공 문제풀이
## 문제 조건
* 1, 2, 3번 컵 중, 먼저 1번 컵 아래에 공을 하나 넣는다.
* 두 컵을 골라서 그 위치를 바꾸는데, 공의 위치는 움직이지 않고 컵의 번호만 바뀐다.
* 컵의 위치를 M번 바꿀 때, 최종적으로 공이 들어있는 컵의 번호 구하기

## 알고리즘 설계
* 공의 위치가 1번 컵에서 시작, 공이 들어있는 컵의 변수 ans에 먼저 1을 저장한다.
* 이후 x번 컵과 y번 컵의 위치를 서로 바꿀 때마다 ans와 같은 번호인 컵이 있는지 판단 후 컵의 번호를 바꿔준다.

[문제 링크](https://www.acmicpc.net/problem/1547)  
[노션 링크](https://www.notion.so/196e378b4c3280e1bf7ac778281302ce)  

---
# 2. 기적의 매매법 문제풀이
## 문제 조건
* 준현이
  + 준현이는 한 번 산 주식은 절대 팔지 않는다.  
  + 살 수 있다면 가능한 만큼 즉시 매수하고 무조건 최대한 많이 산다.  
* 성민이
  + 성민이는 모든 거래를 전량 매수와 전량 매도로 한다.  
  + 3일 연속 가격이 전일 대비 상승하는 주식은 3일째에 전량 매도한다.  
  + 3일 연속 가격이 전일 대비 하락하는 주식은 전량 매수한다.  
* 14일간 준현이와 성민이의 매매법으로 주식 매매를 진행한다.  
* 1월 14일의 자산 = (현금 + 1월 14일의 주가 * 주식 수)  

## 알고리즘 설계
* 준현이 - for문을 돌면서 그날 주식을 살 수 있는지 없는지 판단
* 성현이 - 최근 3일간의 주식 동향에 따라 전량 매수 or 전량 매도 or pass
  + (오늘 vs 내일) and (내일 vs 모레) and (모레 vs 글피) 비교

[문제 링크](https://www.acmicpc.net/problem/20546)  
[노션 링크](https://www.notion.so/196e378b4c3280b1a60ae8a3e964cff4)  

---
# 3. 빙고 문제풀이
## 문제 조건
* 빙고완 - 가로, 세로, 대각선 방향으로 선 세 개 이상
* 사회자가 몇 번째 수를 부른 후에 철수가 빙고를 외치게 되는지 출력  

## 알고리즘 설계
1. 사회자가 번호를 부를 때마다 findIndex() 함수에서 번호의 좌표를 찾는다
2. 그후, lineCheck() 함수에서 앞서 찾은 좌표를 기준으로 가로, 세로, 그리고 좌우 대각선이 1빙고가 되었는지 확인한다.
3. 5개의 번호가 지워졌는지 확인될 때마다 line++하여 3빙고가 됐을 때 결과를 출력한다. 단, 대각선의 경우는 한 번 완성되면 끝이므로 lb, rb 변수를 false로 바꿔서 leftCnt, rightCnt 변수가 계속 증가하지 않도록 한다. 처음 완성됐을 때만 line++한다.

[문제 링크](https://www.acmicpc.net/problem/2578)  
[노션 링크](https://www.notion.so/197e378b4c3280ecba2dec44e966175d)  

---
# 4. 퇴사 문제풀이
## 문제 조건
* (N+1)일 째 되는 날 퇴사, N일 동안 최대한 많은 상담을 진행한다.
* 하루에 하나씩 서로 다른 사람의 상담을 예약한다.
* 상담 기간이 1일보다 클 수 있기 때문에, 모든 사람의 상담을 할 수 없다.
* Ti == 상담 완료 기간, Pi == 상담 금액, 최대 수익 구하기

## 알고리즘 설계
* 마지막날 → 1일로 진행
* ans[i] = i번째 날부터 일했을 때 얻을 수 있는 최대 수익
* Ti[i] = i번째 날의 일의 소요 시간
* Pi[i] = i번째 날의 수익
>  i번째 날에 일을 하는 경우와 일을 안 하는 경우를 비교한다.
> > i번째 날에 일을 한다 → 수익 : Pi[i] + ans[i+Ti[i]] (i번째 날에 일을 한다면 i+Ti[i] 시간동안 다른 일을 할 수 없음, 따라서 i+Ti[i]번째 날부터 일했을 때 얻을 수 있는 최대 수익을 더함)
> > i번째 날에 일을 안 한다 → 수익 : ans[i+1] (다음날 i+1번째부터 일했을 때 얻을 수 있는 최대 수익이 됨)
> 따라서 점화식은 ans[i] = max(ans[i + 1], ans[i+Ti[i]]+Pi[i])

[문제 링크](https://www.acmicpc.net/problem/14501)  
[노션 링크](https://www.notion.so/198e378b4c3280c9a6f1c7ec22f7df9f)  

---
# 5. 스타트와 링크
## 문제 조건
* 짝수 N명의 사람으로 N/2명씩 구성된 2개의 팀을 만든다.
* 팀의 능력치는 팀에 속한 모든 쌍의 능력치 S(i, j)의 합이다. 팀이 (1, 2)이면 팀의 능력치는 S(1, 2) + S(2, 1)이다.
* 만들 수 있는 두 팀의 팀 능력치 차이 중 최솟값 구하기

## 알고리즘 설계
* 브루트포스와 백트래킹 알고리즘 중 어떤 것을 사용할지 고민했다. N의 범위가 20까지인데, 2개의 팀을 구성하는 10명의 모든 조합을 찾다 보면 시간초과가 나올 것 같아서 백트래킹을 사용했다.
* team[i]==1이면  i멤버는 스타트 팀에 들어가고, team[i]==0이면 i멤버는 링크 팀에 들어간다.
* 구성멤버가 N/2가 됐을 때, 스타트 팀과 링크 팀의 팀 능력치를 각각 구한 후 그 차이가 최솟값이 되는지 확인한다. 만약 1, 2번이 스타트 팀, 3, 4번이 링크 팀에 속한 경우, start벡터의 0번째, 1번째에 1, 2가 들어가고 link벡터의 0번째, 1번째에 3, 4번이 들어간다. 이런 방식으로 S(i,j) + S(j,i)의 합을 구한다.

[문제 링크](https://www.acmicpc.net/problem/14889)  
[노션 링크](https://www.notion.so/19ae378b4c32809cb951fd0270bcdc7b)  

---
# 6. 연산자 끼워넣기
## 문제 조건
* N개의 수로 이루어진 수 사이에 N-1개의 연산자를 끼워 넣는다. 연산자의 순서는 변하지 않는다.
* 식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행한다.

## 알고리즘 설계
* 피연산자 배열 opr, 연산자 배열 opt
* 피연산자의 순서는 바뀌지 않고 무조건 앞에서부터 계산을 진행하므로 현재 피연산자에 바로 연산을 수행하여 다음 재귀함수를 호출한다.

[문제 링크](https://www.acmicpc.net/problem/14888)  
[노션 링크](https://www.notion.so/19be378b4c3280cc9b0dfad2088c7cc9)
