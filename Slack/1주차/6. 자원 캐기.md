# :bulb:9095번: 1, 2, 3 더하기
풀이 날짜: 2025-03-07   
유형: DP  
[문제 링크](https://www.acmicpc.net/problem/9095) 

## :pushpin:문제 탐색
### :heavy_exclamation_mark:조건
* 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구한다.
* n은 11보다 작은 양수이다.
* 합을 나타낼 때는 수를 1개 이상 사용해야 한다.

### :heavy_exclamation_mark:탐색
* n==4인 경우, 총 7가지
```
* 1+1+1+1
* 1+1+2
* 1+2+1
* 2+1+1
* 2+2
* 1+3
* 3+1
```
예제에서는 1+1+2와 1+2+1, 2+1+1을 **서로 다른 식으로 보았다.**  
1, 2, 3의 합이라는 점 때문에, n==2일 때 {1+1, 2}와 {1+1} 둘 중 어느 쪽이 맞는지 고민이 되었다.  
1개 이상의 수를 사용해야 한다는 조건에 의해 전자가 맞다는 전제로 1~6까지의 경우를 모두 구해보았다.  

* n==1: 1개
  + 1
* n==2: 2개
  + 1+1
  + 2
* n==3: 4개
  + 1+1+1
  + 1+2, 2+1
  + 3
* n==4: 7개
  + 1+1+1+1
  + 1+1+2, 1+2+1, 2+1+1
  + 2+2
  + 1+3, 3+1
* n==5: 13개
  + 1+1+1+1+1
  + 1+1+1+2, ... 4개
  + 1+1+3, ... 3개
  + 1+2+2, ...3개
  + 2+3, 3+2 2개
* n==6: 24개
  + 1+1+1+1+1+1
  + 1+1+1+1+2, ... 5개
  + 1+1+1+3, ... 4개
  + 1+1+2+2, ... 6개
  + 1+2+3, ... 6개
  + 2+2+2
  + 3+3
---
* dp[n] == n을 1, 2, 3의 합으로 나타낼 수 있는 방법의 수
* dp[1] = 1, dp[2] = 2, dp[3] = 4일 때, dp[4]부터 특이한 부분이 보인다.
``` 
* dp[4] = 7 = dp[1] + dp[2] + dp[3]
* dp[5] = 13 = dp[2] + dp[3] + dp[4]
* dp[6] = 24 = dp[3] + dp[4] + dp[5]
```
* **dp[n] = dp[n-3] + dp[n-2] + dp[n-1]** 의 규칙을 갖는다.
* n==4 ~ n==10(1<=N<=10)의 경우를 모두 구해야 하므로 6번의 loop로 O(6)의 시간이 소요된다.
* T번의 테스트 케이스의 결과를 모두 출력해야 하므로 이 경우에는 O(T)의 시간이 소요된다.
* 따라서 가능한 시간 복잡도는 O(6+T)이고 상수를 무시하면 O(T)가 된다.

## :pushpin:코드 설계
1. N_SIZE == 11의 크기인 dp 배열을 0으로 초기화한다.
2. dp[1], dp[2], dp[3]에 값을 저장한다.
3. n == 4부터 (N_SIZE - 1)을 1, 2, 3으로 나타낼 수 있는 방법의 수를 dp[]에 미리 저장한다.
4. 테스트 케이스의 개수 T를 입력받는다.
5. T번의 while loop동안 양수 n이 입력되면 dp[n]을 출력한다.

## :pushpin:시도 회차 수정 사항
![image](https://github.com/user-attachments/assets/73ccb02c-de2f-4855-af6c-488dad629b42)
### :heavy_exclamation_mark:1회차
``` c++
for (int i = 4; i < N_SIZE; i++)
        dp[i] = dp[i - 1] * 2 - dp[i - 4];
```
* 가장 처음에는 **dp[n-3] + dp[n-2] + dp[n-1]** 라는 규칙을 발견하지 못하였다.
* n==1 ~ n==5까지의 dp[n]만 구했을 때, 단순하게 dp[n] = dp[n-1] * 2 - dp[n-4]라는 식을 세우고 제출했었다.
* 정답처리는 되었지만, dp[n-4]라는 부분 때문에 dp[4]의 값을 올바르게 구하기 위해선 dp[0]에 1이라는 값을 주어야 하는 점이 마음에 들지 않았다.
  
## :pushpin:정답 코드
``` c++
#include<iostream>
#define N_SIZE 11
using namespace std;
//dp[i] == i를 1, 2, 3의 합으로 나타내는 방법의 수
int main() {
        int T;
        int dp[N_SIZE] = { 0, };
        dp[1] = 1; dp[2] = 2; dp[3] = 4;
        for (int i = 4; i < N_SIZE; i++)
                dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
        cin >> T;
        while (T--) {
                int n; cin >> n;
                cout << dp[n] << endl;
        }
}
```
