# :bulb:25418: 정수 a를 k로 만들기
풀이 날짜: 2025-03-19  
유형: DP  
[문제 링크](https://www.acmicpc.net/problem/25418)  

## :pushpin:문제 탐색
### :heavy_exclamation_mark:조건
* 1 <= A, K <= 1,000,000
* 정수 A를 변경할 때 사용할 수 있는 연산 종류는 다음과 같다.
> 1. 연산 1: 정수 A에 1을 더한다.
> 2. 연산 2: 정수 A에 2을 곱한다.
* 정수 A를 K로 만들기 위해 필요한 **최소 연산 횟수**를 구한다.
  
### :heavy_exclamation_mark:탐색
* 5를 10으로 만드는 경우, 필요한 연산은 다음과 같이 생각해 볼 수 있다.
> + 5 -> 6: 연산 1, 1번
> + 6 -> 7: 연산 1, (5->6)연산횟수 + 1, 2번
> + 7 -> 8: 연산 1, (6->7)연산횟수 + 1, 3번
> + 8 -> 9: 연산 1, (7->8)연산횟수 + 1, 4번
> + 9 -> 10: 연산 1, (8->9)연산횟수 + 1, 5번
> + 5 -> 10: 연산 2, 1번
* 연산 1만을 사용하여 5를 10으로 만드는 경우 필요한 연산 횟수는 총 5번인데, 이때 이전 숫자를 만드는데 사용된 연산 횟수에 +1함을 알 수 있다.
* 연산 2 또한 마찬가지이다. 단, 연산 2를 사용하려면 만들어지는 수가 2로 나누어져야 한다.
---
* 이전 결과 값으로 현재의 결과를 만들 수 있으므로 DP를 이용하여 풀 수 있다.  
* dp[i] == i를 만드는데 사용된 최소 연산 횟수, dp[A] == 0  
> * i가 짝수인 경우: dp[i] = min(dp[i-1] + 1, dp[i/2] + 1)  
> * i가 홀수인 경우: dp[i] = dp[i-1] + 1
* A+1부터 K를 모두 탐색해야 하므로 가능한 시간복잡도는 **O(N)** 이다.
## :pushpin:코드 설계
1. A, K를 입력받는다.
2. dp[A]를 0으로 초기화한다.
3. i == A+1부터 K까지 for loop를 돌면서 최소 연산 횟수를 구한다.  
   a. i가 짝수이면 연산 1과 연산 2를 했을 때의 연산 횟수를 비교한다.  
   b. i가 홀수이면 i-1을 만드는데 사용된 연산 횟수에 +1한다.  
4. 최소 연산 횟수를 출력한다.
## :pushpin:시도 회차 수정 사항
![스크린샷 2025-03-19 013143](https://github.com/user-attachments/assets/3e8b6a9a-07a4-45b4-bbeb-e11847e37c30)

## :pushpin:정답 코드
``` c++
#include<iostream>
#include<algorithm>
#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
#define N_SIZE 1000001
using namespace std;
int A, K;
int dp[N_SIZE];//dp[i] == A가 i를 만드는 최소 연산 횟수
int main() {
        fastio;
        cin >> A >> K;
        fill(&dp[A], &dp[K + 1], 987654321);
        dp[A] = 0;
        for (int i = A + 1; i <= K; i++) {
                if (i % 2 == 0 && i / 2 >= A) {//i가 짝수면 연산1, 연산2 비교
                        dp[i] = min(dp[i] + 1, dp[i / 2] + 1);
                }
                else  dp[i] = dp[i - 1] + 1;
        }
        cout << dp[K];
}
```
