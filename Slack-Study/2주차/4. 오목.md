# :bulb:2615: 오목  
풀이 날짜: 2025-03-13  
유형: 구현/시뮬레이션  
[문제 링크](https://www.acmicpc.net/problem/2615)  

## :pushpin:문제 탐색
### :heavy_exclamation_mark:조건
* 바둑판: 19x19
* 왼->오, 위->아래 방향으로 1~19번의 번호가 붙는다.
* **가로, 세로, 대각선 방향**으로 같은 색의 바둑알 다섯 알이 놓이면 해당 색의 승리이다.
* **단, 여섯 알 이상이 연속으로 놓인 경우에는 승리가 아니다.**
* 검은색/흰색의 승리 또는 승부가 결정나지 않은 경우를 판단한다.
---
![image](https://github.com/user-attachments/assets/35f679cc-0a69-4f00-a573-41a973712fde)

![image](https://github.com/user-attachments/assets/f4519fa0-70b4-45a8-b2e9-ff482b7ee17a)

* 검은 바둑알: 1, 흰 바둑알: 2, 알이 놓이지 않는 자리: 0
* 첫 번째 줄에 검은색이 이긴 경우면 1, 흰색이 이긴 경우면 2, 승부가 결정나지 않은 경우면 0을 출력한다.
* 검은색/흰색이 이긴 경우에는 두 번째 줄에 연속된 다섯 개의 바둑알 중에서 가장 왼쪽에 있는 바둑알의 위치를 출력한다.

### :heavy_exclamation_mark:탐색
* 바둑판은 19x19 크기의 2차원 공간이다.
* 오목이 완성되었는지 확인하려면 4가지 방향으로 탐색을 해야 한다.
  + 승리가 확정된 경우, 문제에서 요구하는 것은 가장 왼쪽에 위치하는 바둑알의 좌표이다.
  + 따라서 시작 위치에서 오른쪽에 존재하는 바둑알만 탐색하면 된다.
* dfs, bfs 풀이와 비슷하단 느낌이 들어 늘 그렇듯이 탐색 방향을 결정하는 dx[4], dy[4] 배열을 사용한다.
* 이때 탐색 방향은 시작한 한 방향으로 고정 되어야 한다. (탐색을 가로 방향으로 시작했으면 가로로만, 세로 방향으로 시작했으면 세로로만 탐색)

### :heavy_exclamation_mark:주의
* 오목의 조건은 같은 색의 바둑알 5개가 연속되는 것이다. 6개 이상은 오목에 해당하지 않는다.
* 예를 들자면, 바둑알이 가로 방향으로 (o o o o o o)처럼 되어 있다면, 첫 번째 위치에서 탐색을 시작하는 경우는 육목이기 때문에 오목으로 취급하지 않는다.
* 그런데 두 번째 위치에서 탐색을 시작하면 오목이 된다는 문제가 있다. 19x19 공간을 완전 탐색하기 때문이다.
* 이 부분부터 헷갈리기 시작하여 결국 해설지를 먼저 보고 말았다...
---


## :pushpin:코드 설계


## :pushpin:시도 회차 수정 사항

## :pushpin:정답 코드
``` c++
#include<iostream>
#define MAX_SIZE 20
#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
using namespace std;
//탐색 방향: "연속"된 방향으로 위->아래, 왼->오, 우상향/우하향 대각
//연속된 다섯알이 존재하는 dfs의 "시작 좌표(가장 왼쪽의 돌)" 구하기
//-> 여섯알인 경우를 주의??? -> 연속된 돌의 앞, 뒤쪽 끝도 확인
//xx(xxxxx) -> 여섯 알 이상으로 연속된 돌이기 때문에 해당 안됨
//따라서 탐색 시작 위치의 앞과, 끝난 위치의 뒤도 탐색해야함
int dx[] = { -1, 0, 1, 1 };
int dy[] = { 1,1,1,0 };
int Baduk[MAX_SIZE][MAX_SIZE];
int ansX, ansY;
int isValid(int x, int y) {
        return (0 < x && x < MAX_SIZE && 0 < y && y < MAX_SIZE);
}
int solve(int x, int y) {
        for (int dir = 0; dir < 4; dir++) {//dir 한 방향으로 계속 탐색
                int cnt = 1;
                int nx = x + dx[dir], ny = y + dy[dir];
                while (1) {//뒤쪽 끝까지 탐색
                        if (!isValid(nx, ny)||Baduk[x][y] != Baduk[nx][ny]) break;//연속된 돌이 아님
                        cnt++;
                        if (cnt == 5) {
                                //앞쪽
                                if (isValid(x - dx[dir], y - dy[dir]) && Baduk[x - dx[dir]][y - dy[dir]] == Baduk[x][y])
                                        break;
                                //뒤쪽
                                if (isValid(nx + dx[dir], ny + dy[dir]) && Baduk[nx + dx[dir]][ny + dy[dir]] == Baduk[x][y])
                                        break;
                                return 1;
                        }
                        nx += dx[dir]; ny += dy[dir];
                }
        }
        return 0;
}
int main()
{
        fastio;
        for (int i = 1; i < MAX_SIZE; i++) {
                for (int j = 1; j < MAX_SIZE; j++) cin >> Baduk[i][j];
        }
        for (int i = 1; i < MAX_SIZE; i++) {
                for (int j = 1; j < MAX_SIZE; j++) {
                        if (Baduk[i][j] == 0) continue;
                        if (solve(i, j)) {
                                cout << Baduk[i][j] << "\n";
                                cout << i << " " << j << "\n";
                                return 0;
                        }
                }
        }
        //승부가 안 났으면 0 출력
        cout << 0;
}
```
