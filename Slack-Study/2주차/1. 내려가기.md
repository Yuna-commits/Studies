# :bulb:2096: 내려가기  
풀이 날짜: 2025-03-10  
유형: DP  
[문제 링크](https://www.acmicpc.net/problem/2096)  

## :pushpin:문제 탐색
### :heavy_exclamation_mark:조건
* N개의 줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다.
* 내려가기 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나는 놀이이다.
1. 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라 시작한다.  
2. 다음 줄로 내려갈 때에는 둘 중 하나의 조건을 선택한다.  
   a. 바로 아래의 수로 넘어간다.   
   b. 바로 아래의 수와 붙어 있는 수로 넘어간다.  
  
![image](https://github.com/user-attachments/assets/eeac53ba-b993-4eaa-bbb2-40f392292721)
  
* 별표: 현재 위치
* 파란 동그라미: 다음 줄로 내려갈 수 있는 위치
* 빨간 가위표: 내려갈 수 없는 위치

* 점수는 현재 위치한 곳의 수의 합이며 얻을 수 있는 최대 점수, 최소 점수를 구한다.
### :heavy_exclamation_mark:탐색
* dp[i][j] == i행 j열을 선택할 때 얻을 수 있는 최대/최소 점수
* 현재 위치에서 조건에 맞는 다음 위치로 이동했을 때 그 값이 최대/최소인지를 확인한다.
* 메모리 제한이 4MB이므로 코드를 최대한 간결하게 쓴다.

## :pushpin:코드 설계
1. N과 점수판 1행을 입력 받는다.
2. N-1번의 for loop를 진행하여 2행부터 입력 받는다.
3. 각 행의 최댓값 최솟값을 구한다.

## :pushpin:시도 회차 수정 사항
![image](https://github.com/user-attachments/assets/f9cbe3b9-4b79-4a43-ade2-aac63946d5eb)
* 메모리 제한 때문에 애를 많이 먹었다.
``` c++
dp[0][0] = matrix[0][0]; dp[0][1] = matrix[0][1]; dp[0][2] = matrix[0][2];
for (int i = 0; i < N - 1; i++) {
        for (int j = 0; j < 3; j++) {
                for (int k = 0; k < 3; k++) {
                        int ny = j + mv[k];
                        if (ny < 0 || ny >= 3) continue;
                        dp[i + 1][ny] = max(dp[i + 1][ny], dp[i][j] + matrix[i + 1][ny]);
                }
        }
}
```
* 처음에는 메모리 제한은 신경쓰지 않고 생각나는대로 코드를 설계하였다.
* 현재 위치에서 조건에 맞는 다음 위치로의 점수를 합하여 더 큰 값을 dp에 저장하는 방식인데 당연하게도 메모리 초과가 나왔다.
* for loop를 여러개 사용하는 것이 메모리 초과의 원인이 된 것 같아 1개의 for loop를 사용하여 최대/최소 값을 한 번에 구하도록 수정하였다.
* 마찬가지로 2차원 배열도 메모리를 많이 잡아먹는 것 같아 1차원 배열로 수정하여 for loop동안 각각 다른 값을 받도록 수정하였다.
```c++
cin >> maxd[0] >> maxd[1] >> maxd[2];
for (int i = 1; i < n; i++) {
        cin >> matrix[0] >> matrix[1] >> matrix[2];

        int temp0 = maxd[0];
        int temp1 = maxd[1];
        int temp2 = maxd[2];

        maxd[0] = max(temp0, temp1) + input[0];
        maxd[1] = max(temp0, max(temp1, temp2)) + input[1];
        maxd[2] = max(temp1, temp2) + input[2];

        temp0 = mind[0];
        temp1 = mind[1];
        temp2 = mind[2];

        mind[0] = min(temp0, temp1) + input[0];
        mind[1] = min(temp0, min(temp1, temp2)) + input[1];
        mind[2] = min(temp1, temp2) + input[2];

}
```
for loop는 N-1번 수행되고 점수판의 2행부터 입력 받는다.
## :pushpin:정답 코드
``` c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
void solve(){

    int n;
    int maxV, minV;
    int mind[3] = {0, };
    int maxd[3] = {0, };
    int matrix[3] = {0, };


    cin >> n;

    cin >> maxd[0] >> maxd[1] >> maxd[2];
    mind[0] = maxd[0];
    mind[1] = maxd[1];
    mind[2] = maxd[2];

    for (int i = 1; i < n; i++){
        cin >> matrix[0] >> matrix[1] >> matrix[2];

        int temp0 = maxd[0];
        int temp1 = maxd[1];
        int temp2 = maxd[2];

        maxd[0] = max(temp0, temp1) + input[0];
        maxd[1] = max(temp0, max(temp1, temp2)) + input[1];
        maxd[2] = max(temp1, temp2) + input[2];

        temp0 = mind[0];
        temp1 = mind[1];
        temp2 = mind[2];

        mind[0] = min(temp0, temp1) + input[0];
        mind[1] = min(temp0, min(temp1, temp2)) + input[1];
        mind[2] = min(temp1, temp2) + input[2];

    }
    maxV = max(maxd[0], max(maxd[1], maxd[2]));
    minV = min(mind[0], min(mind[1], mind[2]));

    cout << maxV << " " << minV << '\n';
}
int main(){


    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    solve();
}
```
